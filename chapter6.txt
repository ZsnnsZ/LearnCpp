1.函数基础
实参是形参的初始值。实参类型和形参类型必须匹配

每个形参都要带声明符

函数的返回类型不能是数组类型或者函数类型

局部对象
名字有作用域，对象有生命周期

形参和函数体内部变量都是局部变量

内置类型的未初始化局部变量将产生未定义的值！！

局部静态对象
将局部变量定义成static类型，该对象在第一次执行定义语句时进行初始化，到程序结束时销毁

函数声明
函数必须在使用之前声明，建议把声明写到头文件里，定义写在源文件中

2.参数传递
当形参是引用类型时，称做实参被引用传递，当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象，称做实参被值传递

值传递不会改变原对象

建议使用引用类型的形参代替指针

对于比较大的对象或者不支持拷贝的对象通过引用形参访问

如果函数无需改变引用形参的值，最好使用常量引用

使用引用形参可以返回额外信息

形参顶层const在初始化时会被忽略掉

避免使用普通引用

数组形参
不允许拷贝数组，使用数组时会将其转变成指针
传递数组其实是传递const int*
当只需要读数组元素不需要写的时候，数组形参应该是指向const的指针，如void foo(int (&arr)[10])

传递多维数组时后面的维度不能省略

int main(int arg, char **argv)

initializer_list类型的形参
实参数量未知且类型相同，是一种模版类型
initializer_list<T> lst

3.返回类型
不要返回局部对象的引用或指针，内存失效

函数可以返回花括号包围的值的列表

函数不能返回数组但是可以返回数组的指针或引用、
简化的声明方法，尾置返回类型
auto func(int i) -> int(*)[10]

4.函数重载
同一作用域，函数名相同，形参列表不同

不允许两个重载函数除了返回类型其他都相同

const_cast
可以重载一个返回类型为常量引用的函数，来获得一个普通引用

5.默认实参、内联函数、constexpr
默认实参
一旦某个形参被赋予了默认值，它后面的所有形参都要默认值

内联函数
在返回类型前面加上关键字inline，声明内联函数

内联机制用于优化规模较小，流程直接，频繁调用的函数

constexpr函数
指能用于常量表达式的函数
函数返回类型及所有形参的类型必须是字面值类型
函数必须有且仅有一条return语句

内联函数和constexpr函数通常定义在头文件里

调试帮助
assert预处理宏
assert(expr)
包含cassert头文件后可以直接使用

NDEBUG
如果定义了NDEBUG则assert失效

6.函数匹配
当重载函数的形参数量相等时，以及某些形参的类型可以由其他类型转换得来时

实参类型到形参类型的转换划分分几个等级

内置类型的提升和转换可能在函数匹配时产生意外

7.函数指针
函数指针指向函数
bool (*pf)(const string &, const string &)
括号不能少

可以使用函数指针调用函数

函数指针可以当作形参
作为参数时写成函数或者函数指针是等价的
使用typedef或decltype可以简化使用了函数指针的代码

和数组类似，可以返回指向函数类型的指针

将decltype作用于某个函数时，返回函数类型而不是指针类型